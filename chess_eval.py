# -*- coding: utf-8 -*-
"""Chess_Eval.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xFG9RpmQBA7PcqwsTkB9qu9C4LQJXekq

# Imports
"""

import pandas as pd
import numpy
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score

"""# Load data"""

data = pd.read_csv('labeled_chess_positions.csv')

"""# Define Features
Since the algorithm I have chosen is Random forest I will need to define features for the model to look for.
"""

!pip install python-chess

import chess
import chess.pgn
import chess.engine
import numpy as np

#function for feeature extraction
def extract_features(fen):
    board = chess.Board(fen)
    pieces = {
        "P": board.pieces(chess.PAWN, chess.WHITE),
        "N": board.pieces(chess.KNIGHT, chess.WHITE),
        "B": board.pieces(chess.BISHOP, chess.WHITE),
        "R": board.pieces(chess.ROOK, chess.WHITE),
        "Q": board.pieces(chess.QUEEN, chess.WHITE),
        "K": board.pieces(chess.KING, chess.WHITE),
        "p": board.pieces(chess.PAWN, chess.BLACK),
        "n": board.pieces(chess.KNIGHT, chess.BLACK),
        "b": board.pieces(chess.BISHOP, chess.BLACK),
        "r": board.pieces(chess.ROOK, chess.BLACK),
        "q": board.pieces(chess.QUEEN, chess.BLACK),
        "k": board.pieces(chess.KING, chess.BLACK),
    }

    def count(p):
        return len(pieces[p])

    white_material = count("P") + 3*count("N") + 3*count("B") + 5*count("R") + 9*count("Q")
    black_material = count("p") + 3*count("n") + 3*count("b") + 5*count("r") + 9*count("q")

    def castling_rights():
        return [
            int(board.has_kingside_castling_rights(chess.WHITE)),
            int(board.has_queenside_castling_rights(chess.WHITE)),
            int(board.has_kingside_castling_rights(chess.BLACK)),
            int(board.has_queenside_castling_rights(chess.BLACK)),
        ]

    features = [
        count("P"), count("N"), count("B"), count("R"), count("Q"),
        count("p"), count("n"), count("b"), count("r"), count("q"),
        white_material, black_material, white_material - black_material,
        int(board.turn),
        *castling_rights()
    ]

    return features

"""## Feature extraction
in the above function I have included basic features needed to evaluate a chess position.


*   Peace count
*   Castling rights
*   Checks (not very important)
*   Turn

Note: these features are very basic and will be pretty week to evaluate a complex position for that I found that a neural network is a better alternative that Random Forest.





"""

feature_rows = data['fen'].apply(extract_features)
X = pd.DataFrame(feature_rows.tolist())

"""# Encode labels

now we encode the labels in the csv (White Winning, Black Winning, and Draw) as 0, 1, and 2 respectively.
"""

label_mapping = {"White Winning" : 0, "Black Winning" : 1, "Draw" : 2}
Y = data['label'].map(label_mapping)

"""# Spliting the data

"""

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

"""# Train the model"""

model = RandomForestClassifier(n_estimators=200, random_state=42)

model.fit(X_train, Y_train)

"""# Test Model"""

y_pred = model.predict(X_test)

print("Accuracy:", accuracy_score(Y_test, y_pred))
print("\nClassification Report:\n", classification_report(Y_test, y_pred, target_names=['White Winning', 'Black Winning', 'Draw']))

"""# Load the model"""

import joblib

joblib.dump(model, 'random_forest_fen_model.pkl')